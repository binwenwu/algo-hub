public class _738 {
    public static void main(String[] args) {

    }
    

    public int monotoneIncreasingDigits(int n) {
        
        // ------------------ 预处理部分 ------------------

        // 单个位数的数字（0-9）本身就是单调递增的，直接返回
        if (n < 10) {
            return n;
        }

        // temp 用于存储原始值 n，因为 n 后面会被修改
        int temp = n;

        // arr 用来存储 n 的每一位数字，但是是逆序存储
        // 例如 n = 332, arr 中存储的是 [2, 3, 3, ...]
        int[] arr = new int[10];
        int length = 0; // 用于记录数字的位数

        // 通过循环将 n 的每一位拆分并逆序存入 arr
        while (n > 0) {
            arr[length] = n % 10; // 取出个位数
            length++;
            n = n / 10; // 去掉个位数
        }
        // 循环结束后, length 是数字的位数。例如 n=332, length=3, arr=[2, 3, 3]
        // 为了方便用作数组索引，将其减 1，表示最大索引
        length--; // 现在 length 是 arr 中最高位数字的索引

        // ------------------ 核心逻辑部分 ------------------

        // index 用于标记第一个出现“非单调递增”的位置。
        // 从右往左看，例如 332，在 3 和 2 之间首次出现递减。我们标记 2 的位置。
        // 在逆序数组 arr = [2, 3, 3] 中，这对应 arr[0] 和 arr[1]。
        // arr[0] < arr[1] (即 2 < 3) 说明原数中 arr[1] 对应的位 > arr[0] 对应的位。
        int index = -1;

        // 从左到右遍历原数字（即从高位到低位），寻找第一个破坏单调性的位置
        // 这对应于从右到左遍历逆序数组 arr
        for (int i = length - 1; i >= 0; i--) {
            // arr[i+1] 是原数中较高位，arr[i] 是较低位
            // 如果 arr[i] < arr[i+1]，说明原数中出现了高位大于低位的情况，例如 ...43...
            // 这里应该是 arr[i+1] > arr[i]，你的代码是 arr[i] < arr[i+1]，是等价的
            if (arr[i] < arr[i + 1]) {
                // 记录下这个较低位数字在 arr 中的索引，然后跳出
                index = i;
                break;
            }
        }

        // 如果循环结束后 index 仍然是 -1，说明整个数字是单调递增的
        if (index == -1) {
            return temp; // 直接返回原数
        }

        // ---- 开始改造数字 ----
        // 我们的目标是把破坏点左边的数字减 1，右边全变成 9
        // 例：332 -> 破坏点在3和2之间。我们想把第二个3变成2，把2变成9，得到329。但329不是递增。
        // 正确目标应该是 299。

        // 你的代码通过一个巧妙但复杂的方式实现了这个目标：
        // 1. 先将破坏点及右侧所有数字（在逆序数组中是 index 及更小的索引）都变成 9
        // 对于 n=332, index=0, arr=[2,3,3]。此步将 arr[0] 设为 9。arr 变为 [9, 3, 3]。
        for (int i = 0; i <= index; i++) {
            arr[i] = 9;
        }

        // 2. 将破坏点左侧的数字（在逆序数组中是 index+1）减 1
        // 对于 n=332, index=0。此步将 arr[1] 减 1。arr 变为 [9, 2, 3]。
        arr[index + 1] = arr[index + 1] - 1;

        // 3. 减 1 操作可能导致新的“非单调递增”，需要向左传递这种影响
        // 例如 n=432, 会变成 399。n=332, 会变成 299。
        // 这个循环就是处理这种连锁反应的。
        // 对于 n=332, arr=[9,2,3], index=0, length=2。
        // i 从 0 循环到 1
        // i=0: arr[0]<arr[1] (9<2) 不成立
        // i=1: arr[1]<arr[2] (2<3) 成立。这说明减1后，arr[2]和新的arr[1]构成了新的破坏。
        //    - arr[i] = 9 (即 arr[1]=9)
        //    - arr[i+1]-- (即 arr[2]--)
        //    arr 最终变为 [9, 9, 2]。
        for (int i = index; i < length; i++) {
            if (arr[i] < arr[i + 1]) {
                arr[i] = 9;
                arr[i + 1] = arr[i + 1] - 1;
            }
        }

        // ------------------ 结果重构部分 ------------------

        // 将修改后的逆序数组 arr 重新组合成整数
        int result = 0;
        // 注意：这里是从右到左（低位到高位）遍历逆序数组
        for (int i = 0; i <= length; i++) {
            result = result + ((int) Math.pow(10, i) * arr[i]);
        }

        return result;
    }
}
